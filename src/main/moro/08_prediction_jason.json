{
  "name" : "Discriminative Factorial Models",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "IntroToDiscriminativeFactorialModels",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Discriminative Factorial Models\n\nFactorization is an efficient way of reducing the effective number of parameters in discriminative/predictive models\n\nWe will introduce:\n* Multi-Task/Multi-Label Learning with Matrix Factorization\n* Factorization Machines\n* Structured Prediction with Factorized Parameters",
      "extraFields" : { }
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "MultiTask",
      "extraFields" : { }
    }
  }, {
    "id" : 3,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Multi-Task Learning\n* Inputs: \\\\(d\\\\) feature \\\\(\\mathbf\\phi(x_i)\\in\\Re^d\\\\)\n* Outputs: \\\\(K\\\\) labels \\\\(\\mathbf{y}_i\\in\\lbrace 0,1 \\rbrace^K\\\\)\n\n\\\\( P(\\mathbf{y}_{i}|x_i) = \\prod_{k=1}^K \\mathbf{\\sigma}(\\mathbf\\phi(x_i) \\mathbf{U} \\mathbf{V}_{k:}^T) \\\\)\n\nCan be interpreted as label embedding: \\\\(V_{k:}\\\\) is the \\\\(R\\\\)-dimensional embedding of the \\\\(k\\\\)-th label.",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "MatrixFactorizationAsLinReg",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Structured Prediction\n\nGoal: Predict \\\\(y^* = argmax S(x,y;\\Theta), y \\in T(x) \\\\)\n\n- *y is a structured output\n\n- *\\\\(S(x,y;\\Theta)\\\\) is the score function\n\n- *\\\\(T(x)\\\\) is all possible structures",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "drawbacks1",
      "extraFields" : { }
    }
  }, {
    "id" : 7,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "### Common Examples:\n\n<br />\n<img src=\"../../assets/figures/08/s8s2.png\" height=\"500\">",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "drawbacksTODO",
      "extraFields" : { }
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<br />\n<img src=\"../../assets/figures/08/s8s3.png\" height=\"500\">",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "logic",
      "extraFields" : { }
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<br />\n<img src=\"../../assets/figures/08/s8s4.png\" height=\"500\">",
      "extraFields" : { }
    }
  }, {
    "id" : 12,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "overview",
      "extraFields" : { }
    }
  }, {
    "id" : 13,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<br />\n<img src=\"../../assets/figures/08/s8s5.png\" height=\"500\">",
      "extraFields" : { }
    }
  }, {
    "id" : 14,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "mflogic",
      "extraFields" : { }
    }
  }, {
    "id" : 15,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<br />\n<img src=\"../../assets/figures/08/s8s6.png\" height=\"500\">",
      "extraFields" : { }
    }
  }, {
    "id" : 16,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "injectfacts",
      "extraFields" : { }
    }
  }, {
    "id" : 17,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Difficulties of Manual Feature Selection\n - Few Templates:\n\n -- Poor Performance\n\n - Many Templates:\n\n -- High Performance, Many Parameters\n\n -- Interactions between features can be hard to know\n\n -One option: Automatic Feature Selection:\n\n --Effective, but ''messy'' (Zhao, 2009)\n\n --Expensive\n\n - Solution: Learn templates from data using matrix factorization",
      "extraFields" : { }
    }
  }, {
    "id" : 18,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "difflogic",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "#### Step 1: Formulate Feature Vector as Rank 1 Tensor\n\n - Feature vectors for each type of information: \n\n -- \\\\(\\phi_{head}\\\\), vector \\\\(\\in R^n\\\\) for head token\n\n -- \\\\(\\phi_{child}\\\\), vector \\\\(\\in R^n\\\\)for child token\n\n -- \\\\(\\phi_{arc}\\\\), vector \\\\(\\in R^d\\\\) for arc information",
      "extraFields" : { }
    }
  }, {
    "id" : 20,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "backprop",
      "extraFields" : { }
    }
  }, {
    "id" : 21,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "#### Step 2: Formulate Model Parameters Tensor\n\n - A tensor \\\\(R^{n \\times n \\times d}\\\\), describes the concatenation of all three feature vectors, so replace \\\\(\\Theta\\\\) with tensor \\\\(A\\\\):\n\n $$ S(x,y;\\Theta) = <\\phi_{head} \\otimes \\phi_child> $$ \n\n - Can be huge!  A better option?  Low rank approximation.  Calculate A as: \n\n $$ A = \\sum_i U_i \\otimes V_i \\otimes W_i $$ \n\n Where:\n\n -- r is the rank\n\n -- \\\\(U, V \\in R^{r \\times n}\\\\) replace \\\\(\\phi_{head}\\\\), \\\\(\\phi_{child}\\\\) \n\n -- \\\\(W \\in R^{r\\times d} \\\\) \n\n -- \\\\(U,V,\\\\) and \\\\(W\\\\) are dense low-dimensional representations \\\\(\\in R^r\\\\) ",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "grounding",
      "extraFields" : { }
    }
  }, {
    "id" : 23,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Learning\n\n - Training Objective: \n\n $$ C \\sum_i \\eta_i + ||U||^2 + ||V||^2 + ||W||^2 + ||\\Theta||^2 $$ \n\n Solve non-convex optimization (PA, Crammer, 2006): \n\n For each instance, update \\\\(\\Theta\\\\) and one of the feature tensors as follows: \n\n - \\\\( \\Theta^{(t + 1)} = \\Theta^t + \\Delta \\Theta \\\\) \n\n \\\\( U^{(t+1)} = U^t + \\Delta U \\\\) \n\n Use closed form solution: \n\n $$ \\min_{\\Delta \\Theta, \\Delta U} \\frac{1}{2} ||\\Delta \\Theta ||^2 + \\frac{1}{2} ||\\Delta \\Theta ||^2 + C \\eta_i $$ ",
      "extraFields" : { }
    }
  }, {
    "id" : 24,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "experiments",
      "extraFields" : { }
    }
  }, {
    "id" : 25,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Performance\n\n<br />\n<img src=\"../../assets/figures/08/parse_results.png\" height=\"400\">\n\n - Rank 50 tensors\n\n - Results averaged over 14 languages (CoNLL data)",
      "extraFields" : { }
    }
  }, {
    "id" : 26,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "experiments2",
      "extraFields" : { }
    }
  }, {
    "id" : 27,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## References\n - Koby Crammer, Ofer Dekel, Joseph Keshet, Shia Shalev-Shwartz, and Yoram Singer. \"Online Passive-Aggressive Algorithms\".JMLR. 2006. \n\n - Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay and Tommi Jaakkola. \" Low-Rank Tensors for Scoring Dependency Structures.\"In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp 1381--1391, Baltimore, Maryland, June.\n - Hai Zhao, Wenliang Chen, Chunyu Kit, Guodong Zhou. \"Multilingual Dependency Learning: A Huge Feature Engineering Method to Semantic Dependency Parsing\", CoNLL, 2009.",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
