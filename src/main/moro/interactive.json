{
  "name" : "interactive",
  "cells" : [ {
    "id" : 0,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Interactive",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\nimport ml.wolfe.{Mat, Vect}\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)",
      "extraFields" : {
        "hide_output" : "true",
        "showEditor" : "false",
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val n = 5\nval m = 5 \nval M2 = new DenseTensor2(n, m)\nval rand = new scala.util.Random(0)\nval names = header(\n    Seq(\"D1\",\"D2\",\"D3\",\"D4\",\"D5\"), \n    Seq(\"Greece\",\"Tsipras\",\"Germany\",\"crisis\",\"economy\")) \n    //this should be the data\nval M = parseMatrix(\n    \"\"\"1 2 0 0 0\n       0 0 1 0 0\n       0 0 0 1 1 \n       0 0 1 1 1\n       1 2 1 1 1\"\"\")\nfor (i <- 0 until m; j <- 0 until m) {\n  M2(i, j) = rand.nextGaussian()\n}\n",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\"]"
      }
    }
  }, {
    "id" : 3,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Rendered",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "render(Seq(opacity(matrix(M) + names,0,2)),layout)  ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval M2 = new DenseTensor2(n, m)\\nval rand = new scala.util.Random(0)\\nval names = header(\\n    Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"), \\n    Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")) \\n    //this should be the data\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 1\\\"\\\"\\\")\\nfor (i <- 0 until m; j <- 0 until m) {\\n  M2(i, j) = rand.nextGaussian()\\n}\\n\"]"
      }
    }
  }, {
    "id" : 5,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "SGD",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\n  val rand = new scala.util.Random(0)\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\n  val A = AV._1; val V = AV._2\n  def update(i: Int, j: Int) = {\n    val a = A(i).copy\n    val v = V(j).copy\n    val y = a dot v\n    A(i) += v * alpha * (M(i, j) - y)\n    V(j) += a * alpha * (M(i, j) - y)\n  }\n  for (i <- Range(0,iters).toList) {\n    update(rand.nextInt(M.dim1), \n           rand.nextInt(M.dim2))\n  }\n  (A, V)\n}",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval M2 = new DenseTensor2(n, m)\\nval rand = new scala.util.Random(0)\\nval names = header(\\n    Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"), \\n    Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")) \\n    //this should be the data\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 1\\\"\\\"\\\")\\nfor (i <- 0 until m; j <- 0 until m) {\\n  M2(i, j) = rand.nextGaussian()\\n}\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \"]"
      }
    }
  }, {
    "id" : 7,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Approximated",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\nval m1 = opacity(matrix(M) + names,0,2)\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\nrender(Seq(m1,m2),layout) ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval M2 = new DenseTensor2(n, m)\\nval rand = new scala.util.Random(0)\\nval names = header(\\n    Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"), \\n    Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")) \\n    //this should be the data\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 1\\\"\\\"\\\")\\nfor (i <- 0 until m; j <- 0 until m) {\\n  M2(i, j) = rand.nextGaussian()\\n}\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\"]"
      }
    }
  }, {
    "id" : 9,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "SGDIterations",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val models = for (i <- 0 until 30) yield optimizeL2(M, 2, i, 0.1)\nval matrices = for (m <- models) yield  \n  opacity(matrix(dots(m._1,m._2)) + embeddings(m._1,m._2) + names,0,2)\nrender(matrices,layout)  ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval M2 = new DenseTensor2(n, m)\\nval rand = new scala.util.Random(0)\\nval names = header(\\n    Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"), \\n    Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")) \\n    //this should be the data\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 1\\\"\\\"\\\")\\nfor (i <- 0 until m; j <- 0 until m) {\\n  M2(i, j) = rand.nextGaussian()\\n}\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\",\"val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\\nval m1 = opacity(matrix(M) + names,0,2)\\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\\nrender(Seq(m1,m2),layout) \"]"
      }
    }
  } ],
  "config" : { }
}
